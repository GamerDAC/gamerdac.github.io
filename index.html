<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>GAMERDAC ELITE BBS</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
body{
    margin:0;
    background:black;
    color:#00ff66;
    font-family:'VT323', monospace;
    font-size:20px;
    overflow:hidden;
    animation:flicker .15s infinite;
}

body::after{
    content:"";
    position:fixed;
    top:0;left:0;width:100%;height:100%;
    background:repeating-linear-gradient(
        to bottom,
        rgba(0,255,100,.05),
        rgba(0,255,100,.05) 1px,
        transparent 1px,
        transparent 3px
    );
    pointer-events:none;
}

.vhs{ animation:vhsShift 0.3s infinite; }

@keyframes vhsShift{
    0%{filter:hue-rotate(0deg);}
    50%{filter:hue-rotate(5deg);}
    100%{filter:hue-rotate(0deg);}
}

@keyframes flicker{
    0%{opacity:.98;}
    50%{opacity:1;}
    100%{opacity:.97;}
}

@keyframes pulseGlow{
    0%{box-shadow:0 0 5px #00ff66;}
    50%{box-shadow:0 0 20px #00ff66;}
    100%{box-shadow:0 0 5px #00ff66;}
}

canvas{position:fixed;top:0;left:0;z-index:-1;}

.terminal{
    padding:20px;
    text-shadow:0 0 5px #00ff66,0 0 15px #00ff66;
    max-height:100vh;
    overflow-y:auto;
}

input{
    background:transparent;
    border:none;
    color:#00ff66;
    font-family:'VT323';
    font-size:20px;
    outline:none;
    width:100%;
}

.cpu{
    position:fixed;
    top:10px;
    right:20px;
}

.feed{
    position:fixed;
    bottom:10px;
    right:20px;
    width:300px;
    font-size:16px;
    opacity:.8;
}

.selected{
    background:#00ff66;
    color:black;
    padding:6px;
    animation:pulseGlow 1s infinite;
}
</style>
</head>

<body class="vhs">

<canvas id="matrix"></canvas>
<div class="cpu" id="cpu">CPU: 0%</div>
<div class="feed" id="feed"></div>
<div class="terminal" id="terminal"></div>

<script>
const term=document.getElementById("terminal");
const cpuDisplay=document.getElementById("cpu");
const feed=document.getElementById("feed");

/* MATRIX */
const canvas=document.getElementById("matrix");
const ctx=canvas.getContext("2d");

function resizeCanvas(){
    canvas.height=window.innerHeight;
    canvas.width=window.innerWidth;
}
resizeCanvas();
window.addEventListener("resize",resizeCanvas);

const letters="01";
const fontSize=14;
let columns=Math.floor(canvas.width/fontSize);
let drops=Array(columns).fill(1);

function draw(){
    ctx.fillStyle="rgba(0,0,0,0.05)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="#00ff66";
    ctx.font=fontSize+"px monospace";
    drops.forEach((y,i)=>{
        const text=letters[Math.floor(Math.random()*letters.length)];
        ctx.fillText(text,i*fontSize,y*fontSize);
        if(y*fontSize>canvas.height && Math.random()>0.975) drops[i]=0;
        drops[i]++;
    });
}
setInterval(draw,33);

/* CPU */
setInterval(()=>{
    cpuDisplay.textContent="CPU: "+Math.floor(Math.random()*100)+"%";
},500);

/* FEED */
const messages=[
"[SYS] NODE 03 CONNECTED",
"[WARN] TRACE ROUTE ACTIVE",
"[SYS] ENCRYPTION ENABLED",
"[MSG] meet @ 23:00 node 7",
"[ALERT] gov node ping detected"
];

setInterval(()=>{
    const msg=messages[Math.floor(Math.random()*messages.length)];
    feed.innerHTML=msg+"<br>"+feed.innerHTML.slice(0,200);
},3000);

/* TYPE EFFECT */
function typeLine(text,speed=15){
    return new Promise(res=>{
        const line=document.createElement("div");
        term.appendChild(line);
        let i=0;
        function typing(){
            if(i<text.length){
                line.innerHTML+=text[i++];
                setTimeout(typing,speed);
            }else{
                term.scrollTop=term.scrollHeight;
                res();
            }
        }
        typing();
    });
}

/* BOOT */
async function boot(){
    await typeLine("PRESS ANY KEY TO INITIALIZE MODEM");
    document.addEventListener("keydown",async ()=>{
        await typeLine("BOOTING...");
        await typeLine("640KB RAM OK");
        await typeLine("CONNECT 2400 BAUD");
        await typeLine("WELCOME ELITE USER");
        prompt();
    },{once:true});
}

/* PROMPT */
let selectionMode=false;

function prompt(){
    if(selectionMode) return;

    const input=document.createElement("input");
    input.placeholder="bbs>";
    term.appendChild(input);
    input.focus();

    input.addEventListener("keydown",async e=>{
        if(e.key==="Enter"){
            const cmd=input.value.trim().toLowerCase();
            input.remove();
            await handle(cmd);
            prompt();
        }
    });
}

/* COMMAND HANDLER */
async function handle(cmd){

    if(!cmd){
        await typeLine("");
        return;
    }

    switch(cmd){

        case "help":
            await typeLine("AVAILABLE COMMANDS:");
            await typeLine("help\nrepos\nabout\nclear");
            break;

        case "about":
            await typeLine("GAMERDAC ELITE BBS v3.0");
            await typeLine("KEYBOARD NAVIGATION ENABLED");
            break;

        case "clear":
            term.innerHTML="";
            break;

        case "repos":
            selectionMode=true;

            await typeLine("INITIATING GITHUB BREACH...");
            await typeLine("ACCESSING USER: GamerDAC");
            await new Promise(r=>setTimeout(r,800));

            try{
                const res=await fetch("https://api.github.com/users/GamerDAC/repos");
                const data=await res.json();

                if(!data.length){
                    await typeLine("NO REPOSITORIES FOUND.");
                    selectionMode=false;
                    break;
                }

                await typeLine("=== REPOSITORIES ===");
                await typeLine("↑ ↓ NAVIGATE | ENTER OPEN | ESC EXIT");

                let selectedIndex=0;
                const repoLines=[];

                function render(){
                    repoLines.forEach((line,i)=>{
                        line.classList.remove("selected");
                        if(i===selectedIndex){
                            line.classList.add("selected");
                            line.scrollIntoView({behavior:"smooth",block:"nearest"});
                        }
                    });
                }

                data.forEach(repo=>{
                    const updated=new Date(repo.updated_at).toLocaleDateString();
                    const line=document.createElement("div");
                    line.innerHTML=
                        `${repo.name}
                        | ⭐ ${repo.stargazers_count}
                        | ${repo.language || "N/A"}
                        | Updated: ${updated}
                        <br>${repo.description || "No description"}<br>`;
                    line.style.padding="6px";
                    term.appendChild(line);
                    repoLines.push(line);
                });

                render();

                function keyHandler(e){
                    if(!selectionMode) return;

                    if(e.key==="ArrowDown"){
                        selectedIndex=(selectedIndex+1)%data.length;
                        render();
                        e.preventDefault();
                    }
                    else if(e.key==="ArrowUp"){
                        selectedIndex=(selectedIndex-1+data.length)%data.length;
                        render();
                        e.preventDefault();
                    }
                    else if(e.key==="Enter"){
                        window.open(data[selectedIndex].html_url,"_blank");
                    }
                    else if(e.key==="Escape"){
                        document.removeEventListener("keydown",keyHandler);
                        selectionMode=false;
                        typeLine("EXITING REPO MODE...");
                        prompt();
                    }
                }

                document.addEventListener("keydown",keyHandler);

            }catch(err){
                await typeLine("GITHUB API ERROR");
                selectionMode=false;
            }

            break;

        default:
            await typeLine("UNKNOWN COMMAND");
    }
}

boot();
</script>

</body>
</html>
